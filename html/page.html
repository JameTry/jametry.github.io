<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>&nbsp;</title>
    <link rel="stylesheet" href="/style/post.css">
</head>
<style>
    #content {
        border: 1px solid #ccc;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
    }

    .btn {
        background-color: #f8f8f9;
        padding: 4px 8px;
        border: 1px #595959 solid;
        font-size: 14px;
    }

    .btn:hover {
        background-color: #f0f0f0;
    }

    .input {
        padding: 4px;
        font-size: 14px;
        width: 80px;
    }

    .text {
        width: 400px;
        height: 100px;
        font-size: 14px;
    }

    .toggle .btn {
        border: none;
        display: inline-block;
        cursor: pointer;
        font-size: 16px;
        user-select: none;
        background-color: transparent;
        padding: 0;
        margin-top: 15px;
    }

</style>
<body>
<div class="w">
    <a href="#" onclick="history.back();">è¿”å›</a>
    <br><br>
    <canvas id="content" width="800" height="1000"></canvas>
    <br><br>
    <p><input type="button" class="btn" id="prev" value="ä¸Šä¸€é¡µ" onclick="prev()"><span id="page"> ç¬¬1é¡µ </span><input type="button" class="btn" id="next" value="ä¸‹ä¸€é¡µ" onclick="next()"></p>
    <p>ä½ç½®ï¼š<span id="position">ç‚¹å‡»æœ¬å­è®¾ç½®æ–‡å­—æ‰€åœ¨ä½ç½®</span></p>
    <p>å†…å®¹ï¼š<textarea id="textInput" class="text" placeholder="è¯·è¾“å…¥æ–‡å­—" maxlength="300"></textarea> win+:æ‰“å¼€è¡¨æƒ…</p>
    <p>å¤§å°ï¼š<input type="number" class="input" id="textSize" value="16" min="8" max="40"> 8-40</p>
    <p>é¢œè‰²ï¼š<input type="color" id="textColor" value="#333333"></p>
    <p>è§’åº¦ï¼š<input type="number" class="input" id="angle" min="-360" max="360" step="1" value="0"></p>
    <p><input type="button" class="btn" id="submitBtn" value="ä¿ å­˜"></p>
    <hr>
    <p>çµæ„Ÿæºäºæˆ‘çœ‹åˆ°æˆ‘çš„æœ¬å­ä¸Šä¹±å†™ä¹±ç”»çš„å†…å®¹â€”â€”æ— æ„ä¹‰çš„çº¿æ¡ã€å›¾ç”»ã€æ–‡å­—ã€‚</p>
    <p>åšä¸€ä¸ªå¯ä»¥ä¸€èµ·éšæ„å†™ç”»çš„é¡µé¢ï¼Ÿwhy not?</p>
    <p>è¿˜æœ‰æœ€æœ€æœ€é‡è¦çš„ä¸€ç‚¹ï¼Œæˆ‘ä¸€ç™¾åˆ†æ„Ÿè°¢Cloudflareï¼Œå…è´¹æä¾›äº†å®ç°è¿™ä¸ªåŠŸèƒ½æ‰€éœ€è¦çš„åŸºç¡€æ”¯æŒï¼ŒçœŸçš„å¤§å–„äººğŸ‘¼</p>
    <hr>
    <p>æ“ä½œå¦‚ä¸‹ï¼š</p>
    <p>é¦–å…ˆé…ç½®æ–‡æœ¬å†…å®¹ã€æ ·å¼ï¼Œç„¶åç‚¹å‡»æœ¬å­é€‰æ‹©æƒ³è¦çš„ä½ç½®ã€‚</p>
    <p>å½“æœ¬å­è¢«ç‚¹å‡»åï¼Œå¯ä»¥ä½¿ç”¨Wã€Aã€Sã€Dç¼“æ…¢ç§»åŠ¨ä½ç½®ï¼ŒæŒ‰ä½Shifté”®åŠ é€Ÿç§»åŠ¨ã€‚</p>
    <br><br>
    <div id="tcomment"></div>
    <script>
        //æƒ³å­¦å•Šï¼Ÿæˆ‘æ•™ä½ å•Šã€‚
        const canvas = document.getElementById("content");
        canvas.tabIndex = 0;
        const submitBtn = document.getElementById("submitBtn")
        const ctx = canvas.getContext("2d");
        let textData = [];

        let page = 1;
        let text = document.getElementById("textInput").value;
        let color = document.getElementById("textColor").value;
        let angle = parseFloat(document.getElementById("angle").value);
        let pos = {x: 370, y: 800};
        let size = document.getElementById("textSize").value;
        const SECRET = "jamework";

        const margin = {top: 90, bottom: 30, left: 10, right: 10};
        const lineSpacing = 24;
        const lineMargin = 40;

        let isSaving = false;
        let isFocused = false;

        canvas.addEventListener('click', () => {
            canvas.focus();
        });

        canvas.addEventListener('focus', () => {
            isFocused = true;
            canvas.style.outline = '2px solid #007bff';
        });

        canvas.addEventListener('blur', () => {
            isFocused = false;
            canvas.style.outline = 'none';
        });

        canvas.addEventListener('keydown', (event) => {
            if (!isFocused) return;
            const step = event.shiftKey ? 5 : 1;
            switch (event.key.toLowerCase()) {
                case 'w':
                    pos.y -= step;
                    break;
                case 's':
                    pos.y += step;
                    break;
                case 'a':
                    pos.x -= step;
                    break;
                case 'd':
                    pos.x += step;
                    break;
                default:
                    return;
            }
            event.preventDefault();
            document.getElementById("position").textContent = `x=${pos.x}, y=${pos.y}`;
            render();
        });

        function prev() {
            if (page > 1) {
                page--;
                load();
                render();
            } else if (page == 1) {
                alert("å·²ç»æ˜¯ç¬¬ä¸€é¡µäº†");
            }
        }

        function next() {
            if (page == 10) {
                alert("å·²ç»æ˜¯æœ€åä¸€é¡µäº†");
                return;
            }
            page++;
            load();
            render();
        }

        async function createAuthToken() {
            const timestamp = Date.now().toString();
            const encoder = new TextEncoder();
            const key = await crypto.subtle.importKey(
                "raw",
                encoder.encode(SECRET),
                {name: "HMAC", hash: "SHA-256"},
                false,
                ["sign"]
            );
            const sigBuffer = await crypto.subtle.sign("HMAC", key, encoder.encode(timestamp));
            const signature = Array.from(new Uint8Array(sigBuffer))
                .map(b => b.toString(16).padStart(2, "0"))
                .join("");
            return btoa(`${timestamp}:${signature}`);
        }

        async function load() {
            const token = await createAuthToken();
            fetch(`https://page.jame.work/page/${page}`, {
                headers: {"Authorization": `Bearer ${token}`}
            })
                .then(response => {
                    if (!response.ok) throw new Error('ç½‘ç»œå“åº”ä¸æ­£å¸¸');
                    return response.json();
                })
                .then(data => {
                    textData = data;
                    render();
                })
                .catch(error => {
                    console.error('è¯·æ±‚å¤±è´¥:', error);
                });
        }


        function drawBackground() {
            ctx.save();
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        // ç»˜åˆ¶é¡¶éƒ¨ä¿¡æ¯æ 
        function drawHeader() {
            ctx.save();
            const infoStartX = canvas.width - 200;
            const infoStartY = 50;
            const underlineLength = 150;

            ctx.font = '14px Arial';
            ctx.fillStyle = '#545454';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';

            ctx.fillText('NO:', infoStartX, infoStartY);
            ctx.beginPath();
            ctx.moveTo(infoStartX, infoStartY + 10);
            ctx.lineTo(infoStartX + underlineLength, infoStartY + 10);
            ctx.strokeStyle = '#333';
            ctx.stroke();

            ctx.fillText('Date:', infoStartX, infoStartY + 30);
            ctx.beginPath();
            ctx.moveTo(infoStartX, infoStartY + 35);
            ctx.lineTo(infoStartX + underlineLength, infoStartY + 35);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(margin.left + lineMargin, margin.top);
            ctx.lineTo(canvas.width - margin.right - lineMargin, margin.top);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
        }

        // ç»˜åˆ¶æ¨ªçº¿
        function drawLines() {
            ctx.save();
            const lineStartY = margin.top + 8;
            const lineEndY = canvas.height - margin.bottom;
            const lineCount = Math.floor((lineEndY - lineStartY) / lineSpacing);

            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;

            for (let i = 0; i < lineCount; i++) {
                const y = lineStartY + i * lineSpacing;
                ctx.beginPath();
                ctx.moveTo(margin.left + lineMargin, y);
                ctx.lineTo(canvas.width - margin.right - lineMargin, y);
                ctx.stroke();
            }
            ctx.restore();
        }

        // ç»˜åˆ¶é¡µé¢è£…é¥°
        function drawDecorations() {
            ctx.save();
            ctx.fillStyle = 'rgba(42,42,42,0.2)';
            ctx.fillRect(canvas.width - 3, 3, 3, canvas.height);
            ctx.fillRect(0, canvas.height - 3, canvas.width, 3);
            ctx.fillRect(0, 0, canvas.width, 3);
            drawPage()
        }

        function drawPage() {
            ctx.font = '12px Arial';
            ctx.fillStyle = '#999';
            ctx.textAlign = 'center';
            ctx.fillText(`ç¬¬ ${page} é¡µ`, canvas.width / 2, canvas.height - 25);
            ctx.restore();
            document.getElementById("page").textContent = ` ç¬¬${page}é¡µ `;
        }

        // ç»˜åˆ¶æ–‡å­—
        function drawText(text, x, y, angle, color, size, maxWidth = 500) {
            ctx.save();
            ctx.font = `${size}px serif`;
            ctx.fillStyle = color;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);

            const lineHeight = size * 1.5;
            const paragraphs = text.split(/\r?\n/);

            let offsetY = 0;
            for (let p = 0; p < paragraphs.length; p++) {
                const words = paragraphs[p].split(' ');
                let line = '';

                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;

                    // å¦‚æœè¶…å‡º maxWidthï¼Œå°±æ¢è¡Œ
                    if (testWidth > maxWidth && n > 0) {
                        ctx.fillText(line.trim(), 0, offsetY);
                        line = words[n] + ' ';
                        offsetY += lineHeight;
                    } else {
                        line = testLine;
                    }
                }

                ctx.fillText(line.trim(), 0, offsetY);
                offsetY += lineHeight; // æ®µè½ä¹‹é—´æ¢è¡Œ
            }

            ctx.restore();
        }


        // ç»˜åˆ¶æ•°æ®ä¸­çš„æ–‡å­—
        function drawTextData() {
            for (let i = 0; i < textData.length; i++) {
                const t = textData[i];
                drawText(t.text, t.x, t.y, t.angle, t.color, t.size);
            }
        }

        function render() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();
            drawHeader();
            drawPage();
            drawLines();
            drawTextData();


            if (text.trim() !== "") {
                drawText(text, pos.x, pos.y, angle, color, size);
            }
        }

        load();
        render();

        canvas.addEventListener('click', function (event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            pos.x = Math.round((event.clientX - rect.left) * scaleX);
            pos.y = Math.round((event.clientY - rect.top) * scaleY);
            document.getElementById("position").textContent = `x=${pos.x}, y=${pos.y}`;
            render();
        });

        document.getElementById("textInput").addEventListener("input", e => {
            text = e.target.value;
            render();
        });

        document.getElementById("textColor").addEventListener("input", e => {
            color = e.target.value;
            render();
        });

        document.getElementById("angle").addEventListener("input", e => {
            angle = parseFloat(e.target.value) || 0;
            render();
        });

        document.getElementById("textSize").addEventListener("input", e => {
            size = e.target.value;
            render();
        });

        submitBtn.addEventListener("click", async function () {
            if (isSaving) return;
            isSaving = true;
            submitBtn.disabled = true;
            submitBtn.value = "æäº¤ä¸­...";

            try {
                if (text === "") {
                    alert("è¯·è¾“å…¥æ–‡å­—");
                    return;
                }

                const token = await createAuthToken();
                const response = await fetch('https://page.jame.work/page/add', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        "Authorization": `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        text: text,
                        x: pos.x,
                        y: pos.y,
                        angle: angle,
                        color: color,
                        size: Number(size),
                        page_number: page
                    })
                });
                const data = await response.json();

                if (!response.ok) throw new Error(data.error || "è¯·æ±‚å¤±è´¥");

                alert('ä¿å­˜æˆåŠŸ');

                textData.push({
                    text: text,
                    x: pos.x,
                    y: pos.y,
                    angle: angle,
                    color: color,
                    size: Number(size),
                    page_number: page
                });

                document.getElementById("textInput").value = "";
                text = "";
                render();
            } catch (error) {
                console.error('è¯·æ±‚å¤±è´¥:', error);
                alert(`${error.message}`);
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                isSaving = false;
                submitBtn.disabled = false;
                submitBtn.value = "ä¿ å­˜";
            }
        });

    </script>
    <script src="https://registry.npmmirror.com/twikoo/1.6.41/files/dist/twikoo.min.js"></script>
    <script>
        twikoo.init({
            envId: 'https://comment.jame.work',
            el: '#tcomment',
            lang: 'zh-CN',
        })
    </script>
</div>


</body>

</html>
